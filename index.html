<!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"> <title>Perfect Circle</title> <link rel="preconnect" href="https://fonts.googleapis.com"> <link href="https://fonts.googleapis.com/css2?family=DM+Mono:wght@300;400;500&family=Bebas+Neue&display=swap" rel="stylesheet"> <style> *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; } :root { --bg: #0a0a0a; --surface: #111; --line: #e8e4d9; --accent: #c8f55a; --muted: rgba(232,228,217,0.25); --error: #ff5533; --warn: #ffb340; } html, body { width: 100%; height: 100%; overflow: hidden; background: var(--bg); touch-action: none; user-select: none; -webkit-user-select: none; } #canvas { position: fixed; inset: 0; z-index: 1; cursor: crosshair; } /* Full-screen layout */ #layout { position: fixed; inset: 0; z-index: 10; pointer-events: none; display: flex; flex-direction: column; padding: 28px 32px 20px; } /* TOP BAR */ #topbar { display: flex; align-items: flex-start; justify-content: space-between; flex-shrink: 0; } .label { font-family: 'DM Mono', monospace; font-size: 0.6rem; letter-spacing: 0.2em; text-transform: uppercase; color: var(--muted); line-height: 1; margin-bottom: 4px; } #title-block .title { font-family: 'Bebas Neue', sans-serif; font-size: 1.6rem; letter-spacing: 0.05em; color: var(--line); line-height: 1; } #best-block { text-align: right; } #best-val { font-family: 'Bebas Neue', sans-serif; font-size: 1.4rem; color: var(--accent); line-height: 1; transition: color 0.3s; } /* CENTER */ #center { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center; gap: 6px; } #score { font-family: 'Bebas Neue', sans-serif; font-size: clamp(5rem, 18vw, 10rem); letter-spacing: -0.02em; line-height: 0.9; color: var(--line); transition: color 0.4s ease; will-change: transform; } #score.pop { animation: pop 0.35s cubic-bezier(0.34, 1.56, 0.64, 1); } @keyframes pop { 0% { transform: scale(1); } 40% { transform: scale(1.08); } 100% { transform: scale(1); } } #status { font-family: 'DM Mono', monospace; font-size: 0.7rem; letter-spacing: 0.25em; text-transform: uppercase; color: var(--muted); transition: color 0.3s, opacity 0.3s; min-height: 1em; } /* Radial meter ring */ #meter-ring { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 80vmin; height: 80vmin; pointer-events: none; z-index: 5; opacity: 0; transition: opacity 0.5s; } #meter-ring.visible { opacity: 1; } #meter-ring svg { width: 100%; height: 100%; transform: rotate(-90deg); } #ring-bg { fill: none; stroke: rgba(255,255,255,0.05); stroke-width: 1.5; } #ring-fill { fill: none; stroke: var(--accent); stroke-width: 2; stroke-linecap: round; stroke-dasharray: 283; stroke-dashoffset: 283; transition: stroke-dashoffset 0.8s cubic-bezier(0.34, 1.2, 0.64, 1), stroke 0.4s; } /* BOTTOM BAR */ #bottombar { flex-shrink: 0; display: flex; justify-content: space-between; align-items: flex-end; gap: 12px; } #streak-block {} #streak-val { font-family: 'Bebas Neue', sans-serif; font-size: 1.4rem; color: var(--line); line-height: 1; } #hint { font-family: 'DM Mono', monospace; font-size: 0.58rem; letter-spacing: 0.12em; color: var(--muted); text-align: right; line-height: 1.7; } /* FOOTER â€” always visible, centered */ #footer { flex-shrink: 0; text-align: center; padding-top: 10px; pointer-events: all; font-family: 'DM Mono', monospace; font-size: 0.62rem; letter-spacing: 0.14em; text-transform: uppercase; color: rgba(232, 228, 217, 0.45); } #footer a { color: var(--accent); text-decoration: none; transition: opacity 0.2s; opacity: 0.8; } #footer a:hover { opacity: 1; } /* Toast */ #toast { position: fixed; bottom: 100px; left: 50%; transform: translateX(-50%) translateY(20px); font-family: 'DM Mono', monospace; font-size: 0.65rem; letter-spacing: 0.2em; text-transform: uppercase; background: var(--accent); color: #000; padding: 7px 18px; border-radius: 2px; opacity: 0; pointer-events: none; z-index: 100; transition: opacity 0.2s, transform 0.3s cubic-bezier(0.34,1.56,0.64,1); white-space: nowrap; } #toast.show { opacity: 1; transform: translateX(-50%) translateY(0); } /* Corner decorations */ .corner { position: fixed; width: 18px; height: 18px; z-index: 5; pointer-events: none; opacity: 0.25; } .corner.tl { top:18px; left:18px; border-top:1px solid var(--line); border-left:1px solid var(--line); } .corner.tr { top:18px; right:18px; border-top:1px solid var(--line); border-right:1px solid var(--line); } .corner.bl { bottom:18px; left:18px; border-bottom:1px solid var(--line); border-left:1px solid var(--line); } .corner.br { bottom:18px; right:18px; border-bottom:1px solid var(--line); border-right:1px solid var(--line); } /* Grain overlay */ #grain { position: fixed; inset: 0; z-index: 50; pointer-events: none; opacity: 0.03; background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)'/%3E%3C/svg%3E"); background-size: 150px; } </style> </head> <body> <div class="corner tl"></div> <div class="corner tr"></div> <div class="corner bl"></div> <div class="corner br"></div> <div id="grain"></div> <canvas id="canvas"></canvas> <div id="toast"></div> <div id="meter-ring"> <svg viewBox="0 0 100 100"> <circle id="ring-bg" cx="50" cy="50" r="45"/> <circle id="ring-fill" cx="50" cy="50" r="45"/> </svg> </div> <div id="layout"> <div id="topbar"> <div id="title-block"> <div class="label">App</div> <div class="title">Perfect Circle</div> </div> <div id="best-block"> <div class="label">Best</div> <div id="best-val">â€”</div> </div> </div> <div id="center"> <div id="score">â€”</div> <div id="status">Draw a circle</div> </div> <div id="bottombar"> <div id="streak-block"> <div class="label">Streak</div> <div id="streak-val">0</div> </div> <div id="hint"> One continuous stroke<br> Release to score </div> </div> <div id="footer"> Powered by <a href="https://x.com/anthroberc" target="_blank" rel="noopener">Anthroberc</a> </div> </div> <script> (function() { const canvas = document.getElementById('canvas'); const ctx = canvas.getContext('2d'); const scoreEl = document.getElementById('score'); const statusEl = document.getElementById('status'); const bestEl = document.getElementById('best-val'); const streakEl = document.getElementById('streak-val'); const meterRing = document.getElementById('meter-ring'); const ringFill = document.getElementById('ring-fill'); const toastEl = document.getElementById('toast'); let points = [], isDrawing = false, bestScore = null, streak = 0, toastTimer = null; function resize() { const dpr = window.devicePixelRatio || 1; const w = window.innerWidth, h = window.innerHeight; canvas.width = w * dpr; canvas.height = h * dpr; canvas.style.width = w + 'px'; canvas.style.height = h + 'px'; ctx.scale(dpr, dpr); } window.addEventListener('resize', resize); resize(); function getPos(e) { const s = e.changedTouches ? e.changedTouches[0] : e; return { x: s.clientX, y: s.clientY }; } function onStart(e) { e.preventDefault(); isDrawing = true; points = [getPos(e)]; ctx.clearRect(0, 0, window.innerWidth, window.innerHeight); meterRing.classList.remove('visible'); ringFill.style.strokeDashoffset = 283; scoreEl.textContent = 'â€”'; scoreEl.style.color = 'var(--line)'; statusEl.textContent = 'Recordingâ€¦'; statusEl.style.color = 'var(--muted)'; ctx.strokeStyle = 'rgba(232,228,217,0.9)'; ctx.lineWidth = 3; ctx.lineCap = 'round'; ctx.lineJoin = 'round'; } function onMove(e) { e.preventDefault(); if (!isDrawing) return; const p = getPos(e); const last = points[points.length - 1]; if (Math.hypot(p.x - last.x, p.y - last.y) < 2) return; points.push(p); ctx.beginPath(); if (points.length >= 3) { const p2 = points[points.length - 3]; const p1 = points[points.length - 2]; ctx.moveTo(p2.x, p2.y); ctx.quadraticCurveTo(p1.x, p1.y, (p1.x + p.x) / 2, (p1.y + p.y) / 2); } else { ctx.moveTo(last.x, last.y); ctx.lineTo(p.x, p.y); } ctx.stroke(); } function onEnd(e) { if (!isDrawing) return; isDrawing = false; processCircle(); } canvas.addEventListener('pointerdown', onStart, { passive: false }); window.addEventListener('pointermove', onMove, { passive: false }); window.addEventListener('pointerup', onEnd); window.addEventListener('pointercancel', onEnd); function showToast(msg) { toastEl.textContent = msg; toastEl.classList.add('show'); clearTimeout(toastTimer); toastTimer = setTimeout(() => toastEl.classList.remove('show'), 1800); } function processCircle() { if (points.length < 20) { statusEl.textContent = 'Too short â€” try again'; return; } let sx = 0, sy = 0; points.forEach(p => { sx += p.x; sy += p.y; }); const cx = sx / points.length, cy = sy / points.length; let minX=Infinity, maxX=-Infinity, minY=Infinity, maxY=-Infinity; points.forEach(p => { if (p.x < minX) minX = p.x; if (p.x > maxX) maxX = p.x; if (p.y < minY) minY = p.y; if (p.y > maxY) maxY = p.y; }); const bboxW = maxX - minX, bboxH = maxY - minY; const dists = points.map(p => Math.hypot(p.x - cx, p.y - cy)); const avgR = dists.reduce((a, b) => a + b, 0) / dists.length; const mad = dists.reduce((a, d) => a + Math.abs(d - avgR), 0) / dists.length; const aspect = Math.min(bboxW, bboxH) / Math.max(bboxW, bboxH); const gap = Math.hypot(points[0].x - points[points.length-1].x, points[0].y - points[points.length-1].y); const angles = points.map(p => Math.atan2(p.y - cy, p.x - cx)); let sweep = 0; for (let i = 1; i < angles.length; i++) { let da = angles[i] - angles[i-1]; if (da > Math.PI) da -= 2 * Math.PI; if (da < -Math.PI) da += 2 * Math.PI; sweep += da; } const coverage = Math.min(1, Math.abs(sweep) / (2 * Math.PI)); const relDev = mad / avgR; let score = 100; score -= relDev * 150; if (aspect < 0.85) score -= (0.85 - aspect) * 120; score -= (gap / (2 * avgR)) * 60; if (coverage < 0.9) score -= (0.9 - coverage) * 200; if (relDev > 0.3) score = Math.min(score, 15); const final = Math.max(0, Math.min(99.9, score)); const finalStr = final.toFixed(1); if (final >= 80) { streak++; } else { streak = 0; } streakEl.textContent = streak; if (bestScore === null || final > bestScore) { bestScore = final; bestEl.textContent = finalStr + '%'; bestEl.style.color = final > 90 ? 'var(--accent)' : 'var(--line)'; } let color, statusText; if (final >= 95) { color = 'var(--accent)'; statusText = 'Extraordinary'; showToast('ðŸ”¥ ' + finalStr + '% â€” Flawless!'); } else if (final >= 88) { color = 'var(--accent)'; statusText = 'Excellent'; } else if (final >= 75) { color = 'var(--line)'; statusText = 'Great shape'; } else if (final >= 55) { color = 'var(--warn)'; statusText = 'Getting there'; } else if (final >= 30) { color = 'var(--error)'; statusText = 'Keep practicing'; } else { color = 'var(--error)'; statusText = 'Not a circle'; } scoreEl.textContent = finalStr + '%'; scoreEl.style.color = color; scoreEl.classList.remove('pop'); void scoreEl.offsetWidth; scoreEl.classList.add('pop'); statusEl.textContent = statusText; statusEl.style.color = color; const circumference = 283; const offset = circumference - (final / 100) * circumference; ringFill.style.stroke = color; meterRing.classList.add('visible'); setTimeout(() => { ringFill.style.strokeDashoffset = offset; }, 30); } })(); </script> </body> </html>